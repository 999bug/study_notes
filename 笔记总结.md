# Java基础学习总结

## 函数式编程

> 函数式编程（Functional Programming）

- OO（object oriented,面向对象）是抽象数据
- FP（Functional programming，函数式编程）是抽象行为

### 约束

函数式编程是安全的，它增加了一些约束，即所有的数据（变量、对象）必须是不可变的，设置一次，永不改变。不修改自身外部的任何东西（函数范围之外的元素）

### 优点

不可变对象范式解决了**并发编程**中棘手问题（当程序的某些部分在多处理器同时运行时），意味着不同的处理器可以尝试同时修改同一块内存。

如果函数永远不会修改现有值而是产生新值，则不会对内存产生争用，这是函数式语言天生的优点。

函数式语言作为并行编程的其中之一的解决方案。

### Lambda 表达式

Lambda 表达式使用最小可能的语法编写的函数定义

- Lambda 表达式产生函数，而不是类。
- Lambda 语法尽可能少，这使 Lambda 易于编写和使用

```java
interface Description {
  String brief();
}

interface Body {
  String detailed(String head);
}

interface Multi {
  String twoArg(String head, Double d);
}

public class LambdaExpressions {

  static Body bod = h -> h + " No Parens!";      // [1]

  static Body bod2 = (h) -> h + " More details"; // [2]

  static Description desc = () -> "Short info";  // [3]

  static Multi mult = (h, n) -> h + n;           // [4]

  static Description moreLines = () -> {         // [5]
    System.out.println("moreLines()");
    return "from moreLines()";
  };

  public static void main(String[] args) {
    System.out.println(bod.detailed("Oh!"));
    System.out.println(bod2.detailed("Hi!"));
    System.out.println(desc.brief());
    System.out.println(mult.twoArg("Pi! ", 3.14159));
    System.out.println(moreLines.brief());
  }
}
```

> output:
>
> Oh! No Parens!
> Hi! More details
> Short info
> Pi! 3.14159
> moreLines()
> from moreLines()

#### 语法

>  a -> c

a ：参数

-> : 表示为产出

c : 方法体

上例中展示了 Lambda 的几种使用方法

[1] 当使用一个参数时，可以不需要括号()

[2] 使用括号 () 包裹参数

[3] 如果没有参数则必须使用括号 () 表示空参数列表

[4]  当使用多个参数，将参数列表包裹在括号 () 中

[5] 如果方法体一行写不完，需要使用花括号 {} 将方法体包裹其中，这种情况下需要使用return 来返回

### 方法引用

> 方法引用组成：类名或对象名 :: 方法名称

```java
interface Callable {                        // [1]
    void call(String s);
}

class Describe {
    // show() 的签名（参数和返回类型）符合 Callable 的 call()签名
    void show(String msg) {                   // [2]
        System.out.println(msg);
    }
}

public class MethodReferences {
	// hello() 符合call() 签名
    static void hello(String name) {          // [3]
        System.out.println("Hello, " + name);
    }

    static class Description {
        String about;

        Description(String desc) {
            about = desc;
        }
		// help() 符合call() 签名，它是静态内部类中的非静态方法
        void help(String msg) {                 // [4]
            System.out.println(about + " " + msg);
        }
    }

    static class Helper {
        // assist() 是静态内部类中的静态方法
        static void assist(String msg) {        // [5]
            System.out.println(msg);
        }
    }

    public static void main(String[] args) {
        Describe d = new Describe();
        // 简单理解 映射，将describe.show() 映射给 Callable.call() 方法上
        Callable c = d::show;                   // [6]
        // 通过调用 call() 来调用 show(), java 将 call() 映射到show()
        c.call("call()");                       // [7]
		// 静态方法引用
        c = MethodReferences::hello;            // [8]
        c.call("Bob");
        // 映射：将Description.help()方法映射到 Callable.call() 上
        c = new Description("valuable")::help;  // [9]
        c.call("information");

        c = Helper::assist;                     // [10]
        c.call("Help!");
    }
}
```

> output:
>
> call()
> Hello, Bob
> valuable information
> Help!

#### 未绑定的方法引用

> 未绑定的方法引用是指没有关联对象的普通（非静态）方法。
>
> 使用未绑定的引用时，我们必须先提供对象

```java
class X {
    String f() {
        return "X::f()";
    }
}

interface MakeString {
    String make();
}

interface TransformX {
    String transform(X x);
}

public class UnboundMethodReference {

    public static void main(String[] args) {
        // MakeString ms = X::f;  不可以使用，因为需要绑定方法引用       // [1]
        MakeString makeString = new MakeString() {
            @Override
            public String make() {
                return "hah";
            }
        };
        System.out.println(makeString.make());

        //  TransformX sp1 = X::f; 和下面表达的意思是一样的
        TransformX sp = new TransformX() {
            @Override
            public String transform(X x) {
                return x.f();
            }
        };

        X x = new X();
        System.out.println(sp.transform(x));    // [2]
        System.out.println(x.f()); // Same effect
    }
}
/* Output:
X::f()
X::f()
*/
```

- [1] 我们尝试把 X 的 f() 方法引用赋值给 MakeString。
  - 虽然 make() 和 f() 具有相同的签名，但是编译不通过，会报无效引用（invalid method reference）错误。
  - 这是因为实际上还有一个隐藏的参数：`this` 。你不能在没有 X 对象的前提下调用 f() 。因此 X::f 表示未绑定的方法引用，因为它尚未绑定到对象。
  - 要解决这个问题，我们需要一个 X 对象，索引我们接口中需要一个额外的参数，如上例的 TransformX
  - 如果将 X ：： f 赋值给 TransformX，在 Java 中是允许的。
- 使用**未绑定的引用时**，函数式方法的签名（接口中的单个方法）不再与方法引用的签名完全匹配：原因是：需要一个对象来调用方法

**未绑定方法与多参数的结合使用**

```java
class This {
    void two(int i, double d) {
    }

    void three(int i, double d, String s) {
    }

    void four(int i, double d, String s, char c) {
    }
}

interface TwoArgs {
    void call2(This athis, int i, double d);
}

interface ThreeArgs {
    void call3(This athis, int i, double d, String s);
}

interface FourArgs {
    void call4(This athis, int i, double d, String s, char c);
}

public class MultiUnbound {

    public static void main(String[] args) {
        TwoArgs twoargs = This::two;
        ThreeArgs threeargs = This::three;
        FourArgs fourargs = This::four;

        This athis = new This();
        twoargs.call2(athis, 11, 3.14);
        threeargs.call3(athis, 11, 3.14, "Three");
        fourargs.call4(athis, 11, 3.14, "Four", 'Z');
    }
}

```

#### 构造函数引用

```java
class Dog {
    String name;
    int age = -1; // For "unknown"

    Dog() {
        name = "stray";
    }

    Dog(String nm) {
        name = nm;
    }

    Dog(String nm, int yrs) {
        name = nm;
        age = yrs;
    }
}

interface MakeNoArgs {
    Dog make();
}

interface Make1Arg {
    Dog make(String nm);
}

interface Make2Args {
    Dog make(String nm, int age);
}

public class CtorReference {

    public static void main(String[] args) {
       MakeNoArgs makeNoArgs = Dog::new;
       Make1Arg make1Arg = Dog::new;
       Make2Args make2Args = Dog::new;

       Dog noArgs = makeNoArgs.make();
       Dog args1 = make1Arg.make("ha");
       Dog args2= make2Args.make("11",2);

    }
}

```

### 函数式接口

- @FunctionalInterface 函数式接口：限制接口中只能存在一个抽象方法

- java 8黑魔法：**自动适配函数式接口**（适配你的值到目标接口），编译器会在后台把方法引用或lambda表达式包装进实现目标接口的类中

```java

@FunctionalInterface
interface Functional {
    String goodbye(String arg);
}

interface FunctionalNoAnn {
    String goodbye(String arg);
}

// @FunctionalInterface 作用：接口中如果有多个抽象方法则会产生编译期错误
/*
@FunctionalInterface
interface NotFunctional {
  String goodbye(String arg);
  String hello(String arg);
}
Produces error message:
NotFunctional is not a functional interface
multiple non-overriding abstract methods
found in interface NotFunctional
*/

public class FunctionalAnnotation {

    public String goodbye(String arg) {
        return "Goodbye, " + arg;
    }

    public static void main(String[] args) {

        FunctionalAnnotation fa = new FunctionalAnnotation();
// TODO: 2021/8/30 java 8黑魔法：自动适配函数式接口（适配你的值到目标接口），编译器会在后台把方法引用或lambda表达式包装进实现目标接口的类中
        Functional f = fa::goodbye;
        FunctionalNoAnn fna = fa::goodbye;

        // Functional fac = fa; // Incompatible
        Functional fl = a -> "Goodbye, " + a;
        FunctionalNoAnn fnal = a -> "Goodbye, " + a;
    }
}

```

#### 函数式接口命名准则

1. 如果只处理对象而非基本类型，名称则为 Function，Consumer，Predicate 等。参数类型通过泛型添加

2. 如果接收的参数是基本类型，则由名称的第一部分表示，如 LongConsumer，DoubleFunction，IntPredicate 等，但返回基本类型的 Supplier 接口例外。
3. 如果返回值为基本类型，则用 To 表示，如 ToLongFunction <T> 和 IntToLongFunction。
4. 如果返回值类型与参数类型一致，则是一个运算符：单个参数使用 UnaryOperator，两个参数使用 BinaryOperator。
5. 如果接收两个参数且返回值为布尔值，则是一个谓词（Predicate）。
6. 如果接收的两个参数类型不同，则名称中有一个 Bi。

| 特征                               | 函数式方法名                                            | 示例                                                         |
| ---------------------------------- | ------------------------------------------------------- | ------------------------------------------------------------ |
| 无参数；无返回值                   | Runnable (java.lang) run()                              | Runnable                                                     |
| 无参数；返回类型任意               | Supplier get() getAs 类型 ()                            | Supplier<T><br/>BooleanSupplier<br/>IntSupplier<br/>LongSupplier<br/>DoubleSupplier |
| 无参数；返回类型任意               | Callable(java.util.concurrent)call()                    | Callable<V>                                                  |
| 1 参数；无返回值                   | Consumer accept()                                       | Consumer<T><br/>IntConsumer<br/>LongConsumer<br/>DoubleConsumer |
| 2 参数 Consumer                    | BiConsumer accept()                                     | BiConsumer<T,U>                                              |
| 2 参数 Consumer；1引用；1 基本类型 | Obj 类型 Consumer accept()                              | ObjIntConsumer<T><br/>ObjLongConsumer<T><br/>ObjDoubleConsumer<T> |
| 1 参数；返回类型不同               | Function apply() To 类型和 类型 To 类型<applyAs 类型 () | Function<T,R><br/>IntFunction<R><br/>LongFunction<R><br/>DoubleFunction<R><br/>ToIntFunction<T><br/>ToLongFunction<T><br/>ToDoubleFunction<T><br/>IntToLongFunction<br/>IntToDoubleFunction<br/>LongToIntFunction<br/>LongToDoubleFunction<br/>DoubleToIntFunction<br/>DoubleToLongFunction |
| 1 参数；返回类型相同               | UnaryOperator apply()                                   | UnaryOperator<T><br/>IntUnaryOperator<br/>LongUnaryOperator<br/>DoubleUnaryOperator |
| 2 参数类型相同；返回类型相同       | BinaryOperator apply()                                  | BinaryOperator<T><br/>IntBinaryOperator<br/>LongBinaryOperator<br/>DoubleBinaryOperator |
| 2 参数类型相同; 返回整型           | Comparator (java.util)compare()                         | Comparator<T>                                                |
| 2 参数；返回布尔型                 | Predicate test()                                        | Predicate<T><br/>BiPredicate<T,U><br/>IntPredicate<br/>LongPredicate<br/>DoublePredicate |
| 参数基本类型；返回基本类型         | 类型 To 类型 Function applyAs 类型 ()                   | IntToLongFunction<br/>IntToDoubleFunction<br/>LongToIntFunction<br/>LongToDoubleFunction<br/>DoubleToIntFunction<br/>DoubleToLongFunction |
| 2 参数类型不同                     | Bi 操作 (不同方法名)                                    | BiFunction<T,U,R><br/>BiConsumer<T,U><br/>BiPredicate<T,U><br/>ToIntBiFunction<T,U><br/>ToLongBiFunction<T,U><br/>ToDoubleBiFunction<T> |

使用函数式接口时，名称无关紧要，只要参数类型和返回类型相同即可，Java会将你的方法映射到接口方法。

### 等同 final 效果

```java
// 如果局部变量的初始值永远不会改变，那么它实际上就是 final 的。
class Closure2 {
    // TODO: 2021/8/30  x等同 final 效果
    IntSupplier makeFun(int x) {
        int i = 0;
        return () -> x + i;
    }
}

class Closure3 {
    IntSupplier makeFun(int x) {
        int i = 0;
        // TODO: 2021/8/30 被 Lambda 表达式引用的局部变量必须是 final 或者是等同 final 效果的
        //return () -> x++ + i++; error
        return () -> x;
    }
}

class Closure4 {
    IntSupplier makeFun(final int x) {
        final int i = 0;
        return () -> x + i;
    }
}

```

### 函数组合

| 组合方法                                   | 支持接口                                                     |
| ------------------------------------------ | ------------------------------------------------------------ |
| andThen(argument) 根据参数执行原始操作     | Function BiFunction Consumer<br/>BiConsumer IntConsumer<br/>LongConsumer DoubleConsumer<br/>UnaryOperator IntUnaryOperator<br/>LongUnaryOperator<br/>DoubleUnaryOperator<br/>BinaryOperator |
| compose(argument) 根据参数执行原始操作     | Function UnaryOperator<br/>IntUnaryOperator<br/>LongUnaryOperator<br/>DoubleUnaryOperator |
| and(argument) 短路逻辑与原始谓词和参数谓词 | Predicate BiPredicate IntPredicate<br/>LongPredicate DoublePredicate |
| or(argument) 短路逻辑或原始谓词和参数谓词  | Predicate BiPredicate IntPredicate<br/>LongPredicate DoublePredicate |
| negate() 该谓词的逻辑否谓词                | Predicate BiPredicate IntPredicate<br/>LongPredicate DoublePredicate |

```java
public class FunctionComposition {

    // TODO: 2021/8/30 函数组合
    static Function<String, String> f1 = s -> {
        System.out.println(s);
        return s.replace('A', '_'); },
            f2 = s -> s.substring(3),
            f3 = s -> s.toLowerCase(),
            f4 = f1.compose(f2).andThen(f3);

    public static void main(String[] args) {
        System.out.println(
                f4.apply("GO AFTER ALL AMBULANCES"));
    }
}
/* Output:
AFTER ALL AMBULANCES
_fter _ll _mbul_nces
*/

```

```java
public class PredicateComposition {
    // TODO: 2021/8/30 短路 与 或 非
    static Predicate<String>
            p1 = s -> s.contains("bar"),
            p2 = s -> s.length() < 5,
            p3 = s -> s.contains("foo"),
            p4 = p1.negate().and(p2).or(p3);

    public static void main(String[] args) {
        Stream.of("bar", "foobar", "foobaz", "fongopuckey")
                .filter(p4)
                .forEach(System.out::println);
    }
}
```

## 流式编程

### 开胃菜

```java
// TODO: 2021/8/31 流式编程与普通编程对比
class ImperativeRandoms {
    // TODO: 2021/8/31 外部迭代
    public static void main(String[] args) {
        Random rand = new Random(47);
        SortedSet<Integer> rints = new TreeSet<>();
        while (rints.size() < 7) {
            int r = rand.nextInt(20);
            if (r < 5) {
                continue;
            }
            rints.add(r);
        }
        System.out.println(rints);
    }
}

// TODO: 2021/8/31 使用流的好处：内部迭代产生的代码可读性更强，而且能更简单的的使用多核处理器，
//  通过放弃对迭代的控制，可以把控制权交给并行化机制。
//  流是懒加载的，
public class Randoms {
    // TODO: 2021/8/31 内部迭代
    public static void main(String[] args) {
        // seed（种子）作用，再次运行产生相同的输出
        new Random(47)
                .ints(5, 20) // 产生一个整数流在两个区间内
                .distinct()  // 去重
                .limit(7)  // 保留个数 
                .sorted()  // 升序（默认）逆序Comparator.reverseOrder()
                .forEach(System.out::println); // 方法引用


    }
}
/* Output:
6
10
13
16
17
18
19
*/

```

内部迭代产生的代码可读性更强，而且能更简单的使用多核处理器。通过放弃对迭代流程的控制，可以把控制权交给并行化机制。

流是懒加载的

### 创建流

```java
public class StreamOf {
    // TODO: 2021/8/31 创建流、遍历流
    public static void main(String[] args) {
        // createStream1();
        collectionToStream();
    }

    private static void collectionToStream() {
        List<Bubble> bubbles = Arrays.asList(
                new Bubble(1), new Bubble(2), new Bubble(3));
        // 所有集合都有的stream（），map()获取流中所有的元素，并进行深克隆
        System.out.println(
                // TODO: 2021/8/31 stream()
                bubbles.stream()
                        // 将一个对象流转换成为包含整形数字的IntStream
                        .mapToInt(b -> b.i)
                        .sum());

        Set<String> w = new HashSet<>(Arrays.asList(
                "It's a wonderful day for pie!".split(" ")));
        // strean() 产生一个流，map()获取流中所有的元素，并且对流中元素应用操作从而产生新的元素，并将其传递到后续的流中。
        w.stream()
                .map(x -> x + ",")
                .forEach(System.out::print);
        System.out.println();

        Map<String, Double> m = new HashMap<>();
        m.put("pi", 3.14159);
        m.put("e", 2.718);
        m.put("phi", 1.618);
        // 首先调用 entrySet()产生一个对象流，通过 map()获取所有的对象
        m.entrySet().stream()
                .map(e -> e.getKey() + ": " + e.getValue())
                .forEach(System.out::println);
    }

    private static void createStream1() {
        // TODO: 2021/8/31 Stream.of()
        Stream.of(
                new Bubble(1), new Bubble(2), new Bubble(3))
                .forEach(System.out::println);

        Stream.of("It's ", "a ", "wonderful ",
                "day ", "for ", "pie!")
                .forEach(System.out::print);

        System.out.println();

        Stream.of(3.14159, 2.718, 1.618)
                .forEach(System.out::println);
    }


}
/* Output:
Bubble(1)
Bubble(2)
Bubble(3)
It's a wonderful day for pie!
3.14159
2.718
1.618
*/

```

### 常用方法

#### **stream()**

- 将集合转换成一个流

#### **ints(5, 20)** 

-  产生一个整数流在两个区间内

####  **distinct()**

-   去重

#### **limit(7)**  

- 保留7个元素

####  **sorted()** 

-  升序（默认）
- 逆序 Comparator.reverseOrder()

#### **boxed()**        

- 将基本类型装箱        .

#### **Stream.generate()**

- 把任意Supplier<T> 用于生成T类型的流

####  **collect()** 

- 根据参数来结合所有的流元素
- 对参数进行分割
  - collect(Collectors.joining("，")) 使用逗号分割

#### **sum()**

- 求和

```java
// TODO: 2021/8/31 使用流读取文件
public class RandomWords implements Supplier<String> {

    List<String> words = new ArrayList<>();
    Random rand = new Random(47);

    RandomWords(String fname) throws IOException {
        List<String> lines =
                Files.readAllLines(Paths.get(fname));
        // Skip the first line:
        for (String line : lines.subList(1, lines.size())) {
            // 使用空格 点 逗号 问号 分隔 +表示出现一次或者多次
            for (String word : line.split("[ .?,]+")) {
                words.add(word.toLowerCase());
            }
        }
    }

    @Override
    public String get() {
        return words.get(rand.nextInt(words.size()));
    }

    @Override
    public String toString() {

        return words.stream()
                .collect(Collectors.joining(" "));
    }

    public static void main(String[] args) throws Exception {
        System.out.println(
                // TODO: 2021/8/31 Stream.generate()，把任意Supplier<T> 用于生成 T 类型的流
                Stream.generate(new RandomWords("src/main/resources/Cheese.dat"))
                        .limit(10)
                        // TODO: 2021/8/31 collect() 根据参数来结合所有的流元素，使用逗号分割
                        .collect(Collectors.joining("，")));
    }
}
/* Output:
it shop sir the much cheese by conclusion district is
*/

```

#### **IntStream.range()**

- 左闭右开区间

- 生成区间内的整型序列流

- 可以替换简单的for循环

  - ```
    import static java.util.stream.IntStream.*;
    range(0, 5).forEach(System.out::println);
    ```

    

```java
public class Ranges {
    // TODO: 2021/8/31 range()流操作大用处，转换成数组，计算区间总和
    public static void main(String[] args) {

        // The traditional way:
        int result = 0;
        for (int i = 10; i < 20; i++) {
            result += i;
        }
        System.out.println(result);
        // range(a,b) 左闭右开区间[a,b)
        int[] ints = range(10, 20).toArray();
        System.out.println(Arrays.toString(ints));
        // for-in with a range:
        result = 0;
        for (int i : range(10, 20).toArray()) {
            result += i;
        }
        System.out.println(result);

        // Use streams:
        System.out.println(range(10, 20).sum());
    }
}
/* Output:
145
145
145
*/

```

#### **Stream.iterate()**

- 产生的流的第一个元素是种子，然后将种子传递给方法（iterate 方法的第二个参数）
- 方法运行的结果被添加到流，作为流的第二个元素，并存储起来作为下次调用 iterate()时的第一个参数，以此类推

#### **skip()**

- 跳过的数据个数

```java
public class Fibonacci {
    int x = 1;

    // TODO: 2021/8/31 Stream.iterate()
    Stream<Integer> numbers() {
        return Stream.iterate(0, i -> {
            int result = x + i;
            x = i;
            return result;
        });
    }

    public static void main(String[] args) {
        new Fibonacci().numbers()
                .skip(20) // Don't use the first 20
                .limit(10) // Then take 10 of them
                .forEach(System.out::println);
    }
}
/* Output:
6765
10946
17711
28657
46368
75025
121393
196418
317811
514229
*/

```

#### **Arrays.stream()**

- 把数组转换成为流

```java
public class ArrayStreams {
    // TODO: 2021/8/31 Arrays.stream()将数组转换成流
    public static void main(String[] args) {
        Arrays.stream(
                new double[]{3.14159, 2.718, 1.618})
                .forEach(n -> System.out.format("%f ", n));
        System.out.println();

        Arrays.stream(new int[]{1, 3, 5})
                .forEach(n -> System.out.format("%d ", n));
        System.out.println();

        Arrays.stream(new long[]{11, 22, 44, 66})
                .forEach(n -> System.out.format("%d ", n));
        System.out.println();

        // 第二个参数是从数组哪个位置开始选择元素，第三个参数是在哪里停止，左闭右开区间
        Arrays.stream(
                new int[]{1, 3, 5, 7, 15, 28, 37}, 3, 6)
                .forEach(n -> System.out.format("%d ", n));
    }
}
/* Output:
3.141590 2.718000 1.618000
1 3 5
11 22 44 66
7 15 28
*/

```

#### 正则表达式

**splitAsStream()**

- Pattern.compile("[ .,?]+").splitAsStream(all);

```java
// TODO: 2021/8/31 使用流将文件转换为一个字符串，接着使用正则表达式将字符串转化为单词流
public class FileToWordsRegexp {
    private String all;

    public FileToWordsRegexp(String filePath) throws Exception {
        all = Files.lines(Paths.get(filePath))
                .skip(1) // First (comment) line
                .collect(Collectors.joining(" "));
    }

    public Stream<String> stream() {
        return Pattern.compile("[ .,?]+").splitAsStream(all);
    }

    public static void main(String[] args) throws Exception {

        FileToWordsRegexp fw = new FileToWordsRegexp("src/main/resources/Cheese.dat");
        fw.stream()
                .limit(7)
                .map(w -> w + " ")
                .forEach(System.out::print);
      System.out.println();
        // output Not much of a cheese shop really
        fw.stream()
                .skip(7)
                .limit(2)
                .map(w -> w + " ")
                .forEach(System.out::print);
        // output Not much of a cheese shop really is it
    }
}
/* Output:
Not much of a cheese shop really is it
*/

```

#### peek()

- 无修改的查看流中元素

```java
class Peeking {
    // TODO: 2021/8/31 peek() 瞟一眼 中间操作
    public static void main(String[] args) throws Exception {
        new FileToWordsRegexp("src/main/resources/Cheese.dat").stream()
                .skip(21)
                .limit(4)
                .map(w -> w + " ")
                .peek(System.out::print)
                .map(String::toUpperCase)
                .peek(System.out::print)
                .map(String::toLowerCase)
                .forEach(System.out::print);
    }
}
/* Output:
Well WELL well it IT it s S s so SO so
*/
```

#### filter()

- 若元素传递给过滤函数产生的结果为true，则过滤操作保留这些元素

#### rangeClosed()

- rangeClosed() 包含了上限值 左闭右闭区间

```java
import java.util.stream.*;
import static java.util.stream.LongStream.*;
public class Prime {

    /**
     * 过滤函数，用于检测质数
     */
    public static boolean isPrime(long n) {
        // TODO: 2021/8/31 rangeClosed() 包含了上限值， 
        return rangeClosed(2, (long) Math.sqrt(n))
                .noneMatch(i -> n % i == 0);
        // 如果不能整除，即余数不等于 0，则 noneMatch()
        //操作返回 true，如果出现任何等于 0 的结果则返回 false。noneMatch() 操作一旦有
        //失败就会退出。
    }

    public LongStream numbers() {
        // seed 初始元素，每次加1操作
        return iterate(2, i -> i + 1)
                .filter(Prime::isPrime);
    }

    public static void main(String[] args) {

        new Prime().numbers()
                .limit(10)
                .forEach(n -> System.out.format("%d ", n));
        System.out.println();

        new Prime().numbers()
                .skip(90)
                .limit(10)
                .forEach(n -> System.out.format("%d ", n));
    }
}
/* Output:
2 3 5 7 11 13 17 19 23 29
467 479 487 491 499 503 509 521 523 541
*/

```

#### **map(Function)**

- 将函数操作应用在输入流的元素中，并将返回值传递到输出流中
- 获取对象并产生新的对象

#### **mapToInt(ToIntFunction)**

- 将一个对象流（object stream）转换成为包含整形数字的 IntStream

####  mapToLong(ToLongFunction)：

- 操作同上，但结果是 LongStream。

####  mapToDouble(ToDoubleFunction)：

- 操作同上，但结果是 DoubleStream。

```java
class FunctionMap {
    static String[] elements = {"12", "", "23", "45"};

    /**
     * @return 将数组转换成流返回
     */
    static Stream<String> testStream() {
        return Arrays.stream(elements);
    }

    // TODO: 2021/8/31 map() 的使用方法
    static void test(String descr, Function<String, String> func) {
        System.out.println(" ---( " + descr + " )---");
        testStream()
                .map(func)
                .forEach(System.out::println);
    }

    public static void main(String[] args) {
        // s 表示的是每个集合中的元素
        test("add brackets", s -> "[" + s + "]");

        test("Increment", s -> {
            try {
                return Integer.parseInt(s) + 1 + "";
            } catch (NumberFormatException e) {
                return s;
            }
        });

        test("Replace", s -> s.replace("2", "9"));

        test("Take last digit", s -> s.length() > 0 ?
                s.charAt(s.length() - 1) + "" : s);
    }
}
/* Output:
 ---( add brackets )---
[12]
[]
[23]
[45]
 ---( Increment )---
13

24
46
 ---( Replace )---
19

93
45
 ---( Take last digit )---
2

3
5
*/

```

```java
class FunctionMap3 {
    // TODO: 2021/8/31 使用 mapToInt 将流进行转化
    public static void main(String[] args) {
        Stream.of("5", "7", "9")
                .mapToInt(Integer::parseInt)
                .forEach(n -> System.out.format("%d ", n));
        System.out.println();

        Stream.of("17", "19", "23")
                .mapToLong(Long::parseLong)
                .forEach(n -> System.out.format("%d ", n));
        System.out.println();

        Stream.of("17", "1.9", ".23")
                .mapToDouble(Double::parseDouble)
                .forEach(n -> System.out.format("%f ", n));
    }
}
/* Output:
5 7 9
17 19 23
17.000000 1.900000 0.230000
*/

```

#### flatMap(Function)

- 将产生流的函数应用在每个元素上（与 map()，所做的相同)，
- 然后将每个流都扁平化为元素，因而最终产生的仅仅是元素

#### flatMapToInt(Function)：

- 当 Function 产生 IntStream 时使用。

#### flatMapToLong(Function)：

- 当 Function 产生 LongStream 时使用。

#### flatMapToDouble(Function)：

- 当 Function 产生 DoubleStream 时使用。

```java
public class FlatMap {
	public static void main(String[] args) {
        Stream.of(1, 2, 3)
        .flatMap(i -> Stream.of("Gonzo", "Fozzie", "Beaker"))
        .forEach(System.out::println);
  	}
}
output:
Gonzo
Fozzie
Beaker
Gonzo
Fozzie
Beaker
Gonzo
Fozzie
Beaker
```

####  Stream.of(1，2，3)

- 每次执行几次任务
- 第一次执行1次，第二次执行2次，第三次执行3次

#### concat()

- 以参数顺序组合两个流

**使用整数流创建随机数**

```java
public class StreamOfRandoms {
    static Random rand = new Random(47);

    public static void main(String[] args) {
        // Stream.of()每次执行几次任务
        Stream.of(1, 2, 3, 4, 5)
                .flatMapToInt(i -> IntStream.concat(
                        rand.ints(0, 100).limit(i), IntStream.of(-1)))
                .forEach(n -> System.out.format("%d ", n));
    }
}
/* Output:
58 -1 55 93 -1 61 61 29 -1 68 0 22 7 -1 88 28 51 89 9
-1
*/

```

### Optional

####  findFirst() 

- 返回一个包含第一个元素的 Optional 对象，如果流为空则返回Optional.empty

####  findAny() 

- 返回包含任意元素的 Optional 对象，如果流为空则返回 Op-tional.empty

#### max() 和 min() 

- 返回一个包含最大值或者最小值的 Optional 对象，如果流为空则返回 Optional.empty

> 当流为空的时候你会获得一个 Optional.empty 对象，而不是抛出异常

#### 便利函数

##### ifPresent(Consumer)

- 当值存在时调用 Consumer，否则什么也不做。

##### orElse(otherObject)

- 如果值存在则直接返回，否则生成 otherObject。

##### orElseGet(Supplier)

- 如果值存在则直接返回，否则使用 Supplier 函数生成一个可替代对象。

##### orElseThrow(Supplier)

- 如果值存在直接返回，否则使用 Supplier 函数生成一个异常。

```java
public class Optionals {

    static void basics(Optional<String> optString) {
        if (optString.isPresent()) {
            System.out.println(optString.get());
        } else {
            System.out.println("Nothing inside!");
        }
    }

    // TODO: 2021/8/31 ifPresent 当值存在时调用 consumer，否则什么也不做
    static void ifPresent(Optional<String> optString) {
        optString.ifPresent(System.out::println);
    }

    // TODO: 2021/8/31 orElse 如果值存在直接返回，否则生成otherObject
    static void orElse(Optional<String> optString) {
        System.out.println(optString.orElse("Nada"));
    }

    // TODO: 2021/8/31  orElseGet 如果值存在直接返回，否则使用 Supplier生成一个可替代对象
    static void orElseGet(Optional<String> optString) {
        System.out.println(
                optString.orElseGet(() -> "Generated"));
    }

    // TODO: 2021/8/31  orElseThrow 如果值存在直接返回，否则使用 Supplier生成一个异常
    static void orElseThrow(Optional<String> optString) {
        try {
            System.out.println(optString.orElseThrow(
                    () -> new Exception("Supplied")));
        } catch (Exception e) {
            System.out.println("Caught " + e);
        }
    }

    static void test(String testName, Consumer<Optional<String>> cos) {
        System.out.println(" === " + testName + " === ");
        cos.accept(Stream.of("Epithets").findFirst());
        cos.accept(Stream.<String>empty().findFirst());
    }

    public static void main(String[] args) {
        test("basics", Optionals::basics);
        test("ifPresent", Optionals::ifPresent);
        test("orElse", Optionals::orElse);
        test("orElseGet", Optionals::orElseGet);
        test("orElseThrow", Optionals::orElseThrow);
    }
}
/* Output:
 === basics ===
Epithets
Nothing inside!
 === ifPresent ===
Epithets
 === orElse ===
Epithets
Nada
 === orElseGet ===
Epithets
Generated
 === orElseThrow ===
Epithets
Caught java.lang.Exception: Supplied
*/

```

### 创建Optional

#### empty()

- 生成一个空 Optional。

#### of(value)

- 将一个非空值包装到 Optional 里。

#### ofNullable(value)

- 针对一个可能为空的值，为空时自动生成 Optional.empty，否则将值包装在 Optional 中。

```java
class CreatingOptionals {

    static void test(String testName, Optional<String> opt) {
        System.out.println(" === " + testName + " === ");
        System.out.println(opt.orElse("Null"));
    }

    public static void main(String[] args) {
        // TODO: 2021/8/31 empty() 生成一个空 Optional 
        test("empty", Optional.empty());

        // TODO: 2021/8/31 Optional.of 将一个非空值包装到 Optional里
        test("of", Optional.of("Howdy"));
        System.out.println();
        try {
            test("of", Optional.of(null));
        } catch (Exception e) {
            System.out.println(e);
        }

        // TODO: 2021/8/31 对于一个可能为空的值，为空时自动生成Optional.empty()，否则将值包装在Optional中
        test("ofNullable", Optional.ofNullable("Hi"));
        test("ofNullable", Optional.ofNullable(null));
    }
}
/* Output:
 === empty ===
Null
 === of ===
Howdy
java.lang.NullPointerException
 === ofNullable ===
Hi
 === ofNullable ===
Null
*/

```

#### filter(Predicate)：

- 对 Optional 中的内容应用 Predicate 并将结果返回。如果Optional 不满足 Predicate ，将 Optional 转化为空 Optional 。如果 Optional已经为空，则直接返回空 Optional 。

```java
// TODO: 2021/8/31 使用流 进行过滤数组，不满足条件的为空
class OptionalFilter {

    static String[] elements = {
            "Foo", "", "Bar", "Baz", "Bingo"
    };

    static Stream<String> testStream() {
        return Arrays.stream(elements);
    }

    static void test(String descr, Predicate<String> pred) {
        System.out.println(" ---( " + descr + " )---");
        for (int i = 0; i <= elements.length; i++) {
            System.out.println(
                    testStream()
                            //执行完就跳过这个循环，下次不执行
                            .skip(i)
                            .findFirst()
                            .filter(pred));
        }
    }

    public static void main(String[] args) {
        test("true", str -> true);
        test("false", str -> false);
        test("str != \"\"", str -> str != "");
        test("str.length() == 3", str -> str.length() == 3);
        test("startsWith(\"B\")",
                str -> str.startsWith("B"));
    }
}
/* Output:
 ---( true )---
Optional[Foo]
Optional[]
Optional[Bar]
Optional[Baz]
Optional[Bingo]
Optional.empty
 ---( false )---
Optional.empty
Optional.empty
Optional.empty
Optional.empty
Optional.empty
Optional.empty
 ---( str != "" )---
Optional[Foo]
Optional.empty
Optional[Bar]
Optional[Baz]
Optional[Bingo]
Optional.empty
 ---( str.length() == 3 )---
Optional[Foo]
Optional.empty
Optional[Bar]
Optional[Baz]
Optional.empty
Optional.empty
 ---( startsWith("B") )---
Optional.empty
Optional.empty
Optional[Bar]
Optional[Baz]
Optional[Bingo]
Optional.empty
*/

```

#### map(Function)：

- 如果 Optional 不为空，应用 Function 于 Optional 中的内容，并返回结果。否则直接返回 Optional.empty。



> 同 map() 一样，Optional.map() 执行一个函数。它仅在 Optional 不为空时才执行这个映射函数。并将 Optional 的内容提取出来，传递给映射函数。

```java
class OptionalMap {
    static String[] elements = {"12", "", "23", "45"};

    static Stream<String> testStream() {
        return Arrays.stream(elements);
    }

    // TODO: 2021/8/31 Optional.map() 执行一个函数
    static void test(String descr, Function<String, String> func) {
        System.out.println(" ---( " + descr + " )---");
        for (int i = 0; i <= elements.length; i++) {
            System.out.println(
                    testStream()
                            .skip(i)
                            .findFirst() // Produces an Optional
                            .map(func));
        }
    }

    public static void main(String[] args) {

        // If Optional is not empty, map() first extracts
        // the contents which it then passes
        // to the function:

        test("Add brackets", s -> "[" + s + "]");

        test("Increment", s -> {
            try {
                return Integer.parseInt(s) + 1 + "";
            } catch (NumberFormatException e) {
                return s;
            }
        });

        test("Replace", s -> s.replace("2", "9"));

        test("Take last digit", s -> s.length() > 0 ?
                s.charAt(s.length() - 1) + "" : s);
    }
    // After the function is finished, map() wraps the
    // result in an Optional before returning it:
}
/* Output:
 ---( Add brackets )---
Optional[[12]]
Optional[[]]
Optional[[23]]
Optional[[45]]
Optional.empty
 ---( Increment )---
Optional[13]
Optional[]
Optional[24]
Optional[46]
Optional.empty
 ---( Replace )---
Optional[19]
Optional[]
Optional[93]
Optional[45]
Optional.empty
 ---( Take last digit )---
Optional[2]
Optional[]
Optional[3]
Optional[5]
Optional.empty
*/
```

#### flatMap(Function)：

- 同 map()，但是提供的映射函数将结果包装在 Optional 对象中，因此 flatMap() 不会在最后进行任何包装。

```java
// TODO: 2021/8/31 flatmap() 将提取非空 Optional的内容并将其应用在映射函数，
//  flatMap()不会把结果包装在 Optional中，因为映射函数已经被包装过
//  Optional.flatMap() 是为那些自己已经生成Optiional 的函数设计的
class OptionalFlatMap {
    static String[] elements = {"12", "", "23", "45"};

    static Stream<String> testStream() {
        return Arrays.stream(elements);
    }

    static void test(String descr, Function<String, Optional<String>> func) {
        System.out.println(" ---( " + descr + " )---");
        for (int i = 0; i <= elements.length; i++) {
            System.out.println(
                    testStream()
                            .skip(i)
                            .findFirst()
                            .flatMap(func));
        }
    }

    public static void main(String[] args) {

        test("Add brackets", s -> Optional.of("[" + s + "]"));

        test("Increment", s -> {
            try {
                return Optional.of(
                        Integer.parseInt(s) + 1 + "");
            } catch (NumberFormatException e) {
                return Optional.of(s);
            }
        });

        test("Replace", s -> Optional.of(s.replace("2", "9")));

        test("Take last digit", s -> Optional.of(s.length() > 0 ?
                        s.charAt(s.length() - 1) + "" : s));
    }
}
/* Output:
 ---( Add brackets )---
Optional[[12]]
Optional[[]]
Optional[[23]]
Optional[[45]]
Optional.empty
 ---( Increment )---
Optional[13]
Optional[]
Optional[24]
Optional[46]
Optional.empty
 ---( Replace )---
Optional[19]
Optional[]
Optional[93]
Optional[45]
Optional.empty
 ---( Take last digit )---
Optional[2]
Optional[]
Optional[3]
Optional[5]
Optional.empty
*/
```

### Optional 流

```java
public class StreamOfOptionals {
    public static void main(String[] args) {
        Signal.stream()
                .limit(10)
                .forEach(System.out::println);

        System.out.println(" ---");

        Signal.stream()
                .limit(10)
                // 过滤掉 Optional.empty()
                .filter(Optional::isPresent)
                // 使用get 获取元素
                .map(Optional::get)
                .forEach(System.out::println);
    }
}
/* Output:
Optional[Signal(dash)]
Optional[Signal(dot)]
Optional[Signal(dash)]
Optional.empty
Optional.empty
Optional[Signal(dash)]
Optional.empty
Optional[Signal(dot)]
Optional[Signal(dash)]
Optional[Signal(dash)]
 ---
Signal(dot)
Signal(dot)
Signal(dash)
Signal(dash)
*/
```

### 终端操作

#### toArray()：

- 将流转换成适当类型的数组。

#### toArray(generator)：

- 在特殊情况下，生成自定义类型的数组。

```java
public class RandInts {

    // TODO: 2021/8/31 toArray() 将流转换成适当类型的数组
    private static int[] rints = new Random(47)
            .ints(0, 1000)
            .limit(100)
            .toArray();

    /**
     * 将 100 个数值范围在 0 到 1000 之间的随机数流转换成为数组并将其存储在
     * rints 中。这样一来，每次调用 rands() 的时候可以重复获取相同的整数流。
     */
    public static IntStream rands() {
        return Arrays.stream(rints);
    }
}

```

####  forEach(Consumer) 

- 常见如 System.out::println 作为 Consumer 函数。
- 无序操作

#### forEachOrdered(Consumer)

- 保证 forEach 按照原始流顺序操作。

#### parallel()

- 实现多处理器并行操作
- 实现原理：将流分割为多个（通常为CPU核心数）并在不同处理器上分别执行操作

```java
public class ForEach {
    static final int SZ = 14;

    public static void main(String[] args) {
        RandInts.rands().limit(SZ)
                .forEach(n -> System.out.format("%d ", n));
        System.out.println();
        RandInts.rands().limit(SZ)
                .parallel()
                .forEach(n -> System.out.format("%d ", n));
        System.out.println();
        // TODO: 2021/8/31 在使用 parallel()并行计算后，对于并行流必须使用 forEachOrdered()保证流的顺序性
        RandInts.rands().limit(SZ)
                .parallel()
                .forEachOrdered(n -> System.out.format("%d ", n));
    }
}
/* Output:
258 555 693 861 961 429 868 200 522 207 288 128 551 589
551 589 861 555 288 128 429 207 693 200 258 522 868 961
258 555 693 861 961 429 868 200 522 207 288 128 551 589
*/

```

